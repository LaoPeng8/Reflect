异或: a.同为0, 异为1;
     b.一个数 两次异或后, 就是原数本身    可以利用这个特性进行 加密 或 解密操作

a的ASCII码是97  二进制是 01100001
a     -     01100001
3     -     00000011    3的二进制为什么是00000011   因为 二进制 满二进一  11 第一个1代表2   就像十进制中 11 第一个1代表10一样
                        所以 3 的二进制是11 但是 二进制都是8位的  前面没有的 用0补齐 所以 11 就变成了  00000011
a对3 异或->  01100010  (将a与3的二进制比较[每位数与每为数比较] 同为0, 异为1)  第一次异或后的结果
a对3 再次异或 01100010  (一个数 两次异或后, 就是原数本身(这里指的是a) a在对3进行异或后变成了01100010再次对3进行异或01100010又变回a原本的二进制了)

一个数 两次异或后, 就是原数本身    可以利用这个特性进行 加密 或 解密操作
"xxxx" - 异或一次: 加密
         异或两次: 解密
这说明 用异或的方式加密是可逆的 只要知道 这些数是对哪个数进行异或操作 只需将这些数再次对那个数进行异或操作 即解密了  所以是可逆的.


MD5/SHA256: 字符串  -->  16进制
    需要引入jar   commons-codec.jar

使用MD5/SHA256加密的方式 会将 字符串 转为16进制 相当于加密  (并且是不可逆的)
不可逆的意思是  不能解密(具体可以自己百度  百度上说硬要解密 可以暴力破解)


Base64加密解密 由jdk自带 不需要引入第三方jar






